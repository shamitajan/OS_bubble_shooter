#include <stdio.h>

int main() {
    int n; // number of processes
    int m; // number of resource types
    int i, j, k;

    // Get number of processes and resource types
    printf("Enter the number of processes: ");
    scanf("%d", &n);
    printf("Enter the number of resource types: ");
    scanf("%d", &m);

    int alloc[n][m], max[n][m], avail[m], need[n][m];
    int f[n];       // Finish flag for each process
    int ans[n];     // To store safe sequence
    int ind = 0;    // Index for safe sequence

    // Input Allocation Matrix
    printf("\nEnter Allocation Matrix (%d x %d):\n", n, m);
    for (i = 0; i < n; i++) {
        printf("Process P%d: ", i);
        for (j = 0; j < m; j++) {
            scanf("%d", &alloc[i][j]);
        }
    }

    // Input Max Matrix
    printf("\nEnter Max Matrix (%d x %d):\n", n, m);
    for (i = 0; i < n; i++) {
        printf("Process P%d: ", i);
        for (j = 0; j < m; j++) {
            scanf("%d", &max[i][j]);
        }
    }

    // Input Available Resources
    printf("\nEnter Available Resources (size %d):\n", m);
    for (i = 0; i < m; i++) {
        scanf("%d", &avail[i]);
    }

    // Calculate Need Matrix
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
            need[i][j] = max[i][j] - alloc[i][j];
        }
    }

    // Print Need Matrix
    printf("\nNeed Matrix:\n");
    for (i = 0; i < n; i++) {
        printf("P%d: ", i);
        for (j = 0; j < m; j++) {
            printf("%d ", need[i][j]);
        }
        printf("\n");
    }

    // Initialize finish array
    for (i = 0; i < n; i++) {
        f[i] = 0;
    }

    // Safety Algorithm
    int safe = 1;
    int count = 0;
    int temp_avail[m];
    for(i = 0; i < m; i++) {
        temp_avail[i] = avail[i];
    }

    while (count < n) {
        int found = 0;
        for (i = 0; i < n; i++) {
            if (f[i] == 0) {
                int can_run = 1;
                for (j = 0; j < m; j++) {
                    if (need[i][j] > temp_avail[j]) {
                        can_run = 0;
                        break;
                    }
                }
                if (can_run) {
                    for (j = 0; j < m; j++) {
                        temp_avail[j] += alloc[i][j];
                    }
                    f[i] = 1;
                    ans[ind++] = i;
                    found = 1;
                    count++;
                }
            }
        }
        if (!found) {
            safe = 0;
            break;
        }
    }

    if (safe) {
        printf("\nSystem is in a SAFE state.\n");
        printf("Safe Sequence: ");
        for (i = 0; i < n; i++) {
            printf("P%d", ans[i]);
            if (i != n - 1) printf(" -> ");
        }
        printf("\n");
    } else {
        printf("\nSystem is NOT in a safe state.\n");
    }

    // --- Resource Request Loop ---
    int p;

    do {
        printf("\n--- Resource Request ---\n");
        printf("Enter the process number (0 to %d) making a resource request, or enter a negative number to exit: ", n - 1);
        scanf("%d", &p);

        if (p < 0 || p >= n) {
            printf("Exiting resource request.\n");
            break;
        }

        int req[m];
        printf("Enter request vector for P%d:\n", p);
        for (i = 0; i < m; i++) {
            scanf("%d", &req[i]);
        }

        // Save the original state before applying the request
        int orig_avail[m], orig_alloc[n][m], orig_need[n][m];
        for (i = 0; i < m; i++) {
            orig_avail[i] = avail[i];
        }
        for (i = 0; i < n; i++) {
            for (j = 0; j < m; j++) {
                orig_alloc[i][j] = alloc[i][j];
                orig_need[i][j] = need[i][j];
            }
        }

        // Check if request <= need
        int error = 0;
        for (i = 0; i < m; i++) {
            if (req[i] > need[p][i]) {
                printf("\nError: Request exceeds the process's maximum need.\n");
                error = 1;
                break;
            }
        }
        if (error) continue;

        // Check if request <= available
        for (i = 0; i < m; i++) {
            if (req[i] > avail[i]) {
                printf("\nResources not available. Process must wait.\n");
                error = 1;
                break;
            }
        }
        if (error) continue;

        // Tentatively allocate requested resources
        for (i = 0; i < m; i++) {
            avail[i] -= req[i];
            alloc[p][i] += req[i];
            need[p][i] -= req[i];
        }

        // Check new safety
        for (i = 0; i < n; i++) f[i] = 0;
        ind = 0;
        for (i = 0; i < m; i++) temp_avail[i] = avail[i];

        safe = 1;
        count = 0;
        while (count < n) {
            int found = 0;
            for (i = 0; i < n; i++) {
                if (f[i] == 0) {
                    int can_run = 1;
                    for (j = 0; j < m; j++) {
                        if (need[i][j] > temp_avail[j]) {
                            can_run = 0;
                            break;
                        }
                    }
                    if (can_run) {
                        for (j = 0; j < m; j++) {
                            temp_avail[j] += alloc[i][j];
                        }
                        f[i] = 1;
                        ans[ind++] = i;
                        found = 1;
                        count++;
                    }
                }
            }
            if (!found) {
                safe = 0;
                break;
            }
        }

        if (safe) {
            printf("\nRequest can be granted. System remains in a SAFE state.\n");
            printf("New Safe Sequence: ");
            for (i = 0; i < n; i++) {
                printf("P%d", ans[i]);
                if (i != n - 1) printf(" -> ");
            }
            printf("\n");
        } else {
            printf("\nRequest CANNOT be granted. It leads to an unsafe state.\n");
        }

        // Restore the original state so that each request is treated independently
        for (i = 0; i < m; i++) {
            avail[i] = orig_avail[i];
        }
        for (i = 0; i < n; i++) {
            for (j = 0; j < m; j++) {
                alloc[i][j] = orig_alloc[i][j];
                need[i][j] = orig_need[i][j];
            }
        }

    } while (1); // Loop until user chooses to exit

    return 0;
}

